import nextChunk from './language-model.js';

export async function* generateText(contextSize = 8) {
    // Handle the textbox-level of the autocomplete feature

    yield ""; // Initial empty yield

    // Extract context from textBox
    const context = textBox.value.slice(-contextSize);

    // Get words from the nextChunk generator
    // TODO: set the end condition for the generator (" ", "." or "\n")
    for await (const word of nextChunk(context, contextSize)) {
        yield word; // Yield each word generated by nextWord
    }
}

function updateUI(text, value, suggestionWrapper) {
    // Handles the UI updates for the autocomplete feature
    suggestionWrapper.innerHTML = 
        value + `<span class="suggestion">${text}</span>`;
}

const textBox = document.getElementById('textBox');
const suggestionWrapper = document.getElementById('suggestionWrapper');

let autocompleteText = ''; // Current autocomplete suggestion
let generatorController = null; // To manage the generator loop


// Event listener for input
textBox.addEventListener('input', async () => {
    const value = textBox.value;
    const lastChar = value.slice(-1);

    // Reset suggestion if last character is '.' or ' ' or if the text is empty
    if (lastChar === '.' || lastChar === ' ' || !value) {
        suggestionWrapper.innerHTML = value; // Match the text so far
        autocompleteText = '';

        // Stop any running generator
        if (generatorController) {
            generatorController.abort();
            generatorController = null;
        }
    } else {
        // Stop any previous generator loop
        if (generatorController) {
            generatorController.abort();
        }

        // Start a new generator loop
        generatorController = new AbortController(); // Create a new abort signal
        const signal = generatorController.signal;
        const textGenerator = generateText();

        try {
            for await (const text of textGenerator) {
                if (signal.aborted) {
                    break; // Exit the loop if aborted
                }
                autocompleteText = text;
                updateUI(autocompleteText, value, suggestionWrapper);
            }
        } catch (err) {
            if (err.name !== 'AbortError') {
                console.error('Unexpected error:', err);
            }
        }
    }
});

// Event listener for Tab key
textBox.addEventListener('keydown', (event) => {
    console.log(autocompleteText)
    
    if (event.key === 'Tab' && autocompleteText) {
        event.preventDefault(); // Prevent default Tab behavior
        textBox.value += autocompleteText; // Add autocomplete
        
        if (![" ", "\n"].includes(autocompleteText.slice(-1))) {
            textBox.value += ' '; // Add a space if not already present
        }

        suggestionWrapper.innerHTML = textBox.value; // Update the wrapper
        autocompleteText = ''; // Reset autocomplete

        // Reset the generator
        if (generatorController) {
            generatorController.abort();
            generatorController = null;
        }
    }
});

// Sync suggestion position and style
textBox.addEventListener('scroll', () => {
    suggestionWrapper.scrollTop = textBox.scrollTop;
});